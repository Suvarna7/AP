/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package optrecursive_testbench;

import Jama.Matrix;
import java.io.File;
import java.util.*;
//stuff we need for configuration
import org.apache.commons.configuration2.beanutils.BeanDeclaration;
import org.apache.commons.configuration2.beanutils.BeanHelper;
import org.apache.commons.beanutils.BeanIntrospector;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.configuration2.beanutils.XMLBeanDeclaration;
import org.apache.commons.configuration2.*;
import org.apache.commons.configuration2.ex.*;
import org.apache.commons.configuration2.builder.fluent.Configurations;
import org.apache.commons.configuration2.tree.xpath.XPathExpressionEngine;
import org.apache.commons.logging.*;

/**
 *
 * @author User
 */
public class DIAS {

    //Property : current processing environment. 
    // This allows us to switch between <processing> nodes in the configuration XML 
    // by using the @env attribute. 
    public static String configurationEnvironment = "none";
    public static Boolean verboseMode = false; 
    //Property: excel files to save/load variables
    //TODO make sure files exist in the given path
    public static String excelFilePath;
    //Property: Name of the subdirectory to use when saving / loading data
    public static String excelSubdirectory; 
    //Property: File for Bodymedia read values
    //TODO make sure this file is the same as the xls generated by BodyMedia
    public static String bodymediaFileUrl;
    //Property: Email to receive messages
    public static String[] privateMails;
    
    //Default values for the GUI
    public static Double gs_initial; 
    public static Double ee_in; 
    public static Double gsr_in; 
    public static Double sleep_in; 
    public static Double phys_act_in; 
    public static Double body_weight;
    
    //Default values for processing
    public static int kj_start; 

    //////////////////////////////Matrix Handling functions for the Program/////////////////////////////////////////////////////////////////////////////////////////
    /**
     * createNewMatrix - creates a new 2D matrix from an old matrix. 
     * Increases the size
     * 
     * Typically used to duplicate a matrix as : 
     * Matrix newMatrix = DIAS.createnewMatrix(oldMatrix.getRowDimension(), oldMatrix.getColumnDimension(), oldMatrix); 
     * @param newdimensionx
     * @param newdimensiony
     * @param oldmatrice
     * @return 
     */
    public static Matrix createnewMatrix(int newdimensionx, int newdimensiony, Matrix oldMatrix) {
        Matrix newMatrice = new Matrix(newdimensionx, newdimensiony);

        for (int i = 0; i < oldMatrix.getRowDimension(); i++) {
            for (int j = 0; j < oldMatrix.getColumnDimension(); j++) {
                newMatrice.set(i, j, oldMatrix.get(i, j));
            }
        }

        return newMatrice;
    }
    
    public static Matrix absMatrix(Matrix m1) { 
        Matrix r = new Matrix(m1.getRowDimension(), m1.getColumnDimension());
        for (int i = 0; i < m1.getRowDimension(); i++) {
            for (int j = 0; j < m1.getColumnDimension(); j++) {
                Double curValue = m1.get(i, j); 
                r.set(i, j, (curValue < 0 ? -curValue : curValue)); 
            }
        }
        return r; 
    } 
    
    //XXX OPTIMIZE : Make sure that the matrices are the same dimensions. 
    /**
     * maxMatrix : takes two matrices of the same size and returns a matrix filled with the value from m1 or m2, whichever is greater. 
     * 
     * @param m1
     * @param m2
     * @return 
     */
    public static Matrix maxMatrix(Matrix m1, Matrix m2) { 
        Matrix r = new Matrix(m1.getRowDimension(), m1.getColumnDimension()); 
        for (int i = 0; i < m1.getRowDimension(); i++) {
            for (int j = 0; j < m1.getColumnDimension(); j++) {
                r.set(i, j, Math.max(m1.get(i, j), m2.get(i, j))); 
            }
        }
        return r; 
    } 

    public static Double meanMatrix(Matrix m1) { 
        Double sum = new Double(0); 
        Double items = new Double(0); 
        if (!(m1.getRowDimension() == 0 && m1.getColumnDimension() == 0)) { 
            for (int i = 0; i < m1.getRowDimension(); i++) { 
                for (int j = 0; j < m1.getColumnDimension(); j++) { 
                    sum = sum + m1.get(i, j); 
                    items++; 
                } 
            } 
        return sum / items; 
        }
        else { 
            return new Double(0); 
        } 
        
    }
                
    
    /**
     * printMatrix - print on terminal a 2D matrix an its name
     *
     * @param m
     * @param name
     */
    public static void printMatrix(Matrix m, String name) {
        String dimensions = " (" + Integer.toString(m.getRowDimension()) + " rows x " + Integer.toString(m.getColumnDimension()) + ") "; 
        System.out.print("\n " + name + dimensions + ": \n{");
        for (double[] row : m.getArray()) {
            for (double val : row) {
                System.out.print(" " + val);
            }
            System.out.println();
        }
        System.out.println("}");
    }

    /**
     * print3DMatrix - - print on terminal a 3D matrix an its name
     *
     * @param x - 3D array (matrix)
     * @param matrixname
     */
    public static void print3DMatrix(double x[][][], String matrixname) {

        int[] valuex;
        valuex = lastValueReturnXYZ(x);

        System.out.println(matrixname);

        for (int k = 0; k < valuex[3] + 1; k++) {
            for (int i = 0; i < valuex[1] + 1; i++) {
                for (int j = 0; j < valuex[2] + 1; j++) {
                    System.out.print("\t\t\t" + x[i][j][k]);
                }
                System.out.println();
            }
            System.out.println("Matrice State:  " + (k + 1));
        }
        System.out.println("Matrice has written");

    }

    /**
     * lastValueReturnXYZ - returns the last non zero value in each of the
     * coordinates XYZ
     *
     * @param s - 3D array (matrix)
     * @return
     */
    public static int[] lastValueReturnXYZ(double s[][][]) {
        int lastvaluex = 0;
        int lastvaluey = 0;
        int lastvaluez = 0;

        for (int i = 0; i < s.length; i++) {
            for (int j = 0; j < s[0].length; j++) {
                for (int z = 0; z < s[0][0].length; z++) {
                    if (s[i][j][z] != 0) {
                        lastvaluex = i;
                        lastvaluey = j;
                        lastvaluez = z;
                    }
                }
            }
        }
        int[] dizi = new int[4];
        dizi[1] = lastvaluex;
        dizi[2] = lastvaluey;
        dizi[3] = lastvaluez;

        return dizi;
    }
    /**
     * matrixLastValueReturnX - return the position of the last non zero value
     * in the matrix
     * @param s
     * @return 
     */

    public static int[] matrixLastValueReturnXY(Matrix s) {
        int lastvaluex = 0;
        int lastvaluey = 0;

        for (int i = 0; i < s.getColumnDimension(); i++) {
            for (int j = 0; j < s.getRowDimension(); j++) {
                if (s.get(i, j) != 0) {
                    lastvaluex = i;
                    lastvaluey = j;
                }
            }
        }
        int[] resultlocation = new int[2];
        resultlocation[0] = lastvaluex;
        resultlocation[1] = lastvaluey;

        return resultlocation;
    }
    
    

}
