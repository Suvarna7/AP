/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package dias;

import Jama.Matrix;
import java.io.File;
import javax.mail.MessagingException;
import java.util.*;
//stuff we need for configuration
import org.apache.commons.configuration2.beanutils.BeanDeclaration;
import org.apache.commons.configuration2.beanutils.BeanHelper;
import org.apache.commons.beanutils.BeanIntrospector;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.configuration2.beanutils.XMLBeanDeclaration;
import org.apache.commons.configuration2.*;
import org.apache.commons.configuration2.ex.*;
import org.apache.commons.configuration2.builder.fluent.Configurations;
import org.apache.commons.configuration2.tree.xpath.XPathExpressionEngine;
import org.apache.commons.logging.*;

/**
 *
 * @author User
 */
public class DIAS {

    //Property : current processing environment. 
    // This allows us to switch between <processing> nodes in the configuration XML 
    // by using the @env attribute. 
    public static String configurationEnvironment = "none";
    public static Boolean verboseMode = false; 
    //Property: excel files to save/load variables
    //TODO make sure files exist in the given path
    public static String excelFilePath;
    //Property: Name of the subdirectory to use when saving / loading data
    public static String excelSubdirectory; 
    //Property: File for Bodymedia read values
    //TODO make sure this file is the same as the xls generated by BodyMedia
    public static String bodymediaFileUrl;
    //Property: Email to receive messages
    public static String[] privateMails;
    
    //Default values for the GUI
    public static Double gs_initial; 
    public static Double ee_in; 
    public static Double gsr_in; 
    public static Double sleep_in; 
    public static Double phys_act_in; 
    public static Double body_weight;
    
    //Default values for processing
    public static int kj_start; 
   
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws MessagingException, Exception {
        //Set up configuration here so we can read from the configuration file for our previously-static 
        // variables. 
        boolean configureOK = configureSession();

        System.out.print("Excel file master directory : " + excelFilePath); 
        if (new File(excelFilePath).exists()) { 
            System.out.println(" (directory exists : true)"); 
        } 
        else { 
//            if (!(new File(excelFilePath).mkdirs())) { 
//                System.out.println(" ... but this directory could not be created."); 
//                configureOK = false; 
//            } 
//            else { 
//                System.out.println(" (directory created)"); 
//            }
            System.out.println(" (directory does not exist!)"); 
            configureOK = false; 
        }
            
        System.out.print("Excel files will load from directory : " + DIAS.excelFilePath + File.separator + DIAS.excelSubdirectory);
        if (!(new File(DIAS.excelFilePath + File.separator + DIAS.excelSubdirectory).exists())) { 
//            if (!(new File(DIAS.excelFilePath + File.separator + DIAS.excelSubdirectory).mkdirs())) { 
//            System.out.println("... but this directory could not be created."); 
//            configureOK = false; 
//            }
//            else { 
//                System.out.println(" (directory created)"); 
//            }
            System.out.println(" (directory does not exist!)"); 
            configureOK = false; 
        }
        else { 
            System.out.println(" (directory exists : true)"); 
        } 
        System.out.print("Biometric data will read from file : " + bodymediaFileUrl); 
        if (!(new File(bodymediaFileUrl).exists())) { 
            System.out.println(" (file does not exist!)"); 
            configureOK = false; 
        } 
        else { 
            System.out.println(" (file exists)");
        } 
        if (!(configureOK)) { System.out.println("Configuration failed. Exiting application."); } 

        //Start Graphical interface
        //XXX restore this next line before merging with master. 
        if (configureOK) {
            new GUI().setVisible(true);
        }

        //  ChocaNonLinear ch = new ChocaNonLinear ();
        //   ch.Choca();
    }

    //Is it bad that this method is referencing our now-global variables? Eh, maybe. 
    //This only needs to run here, though. We can expand to a full class with a factory etc. 
    // for all our platform-specific global variables if we need to. 
    public static boolean configureSession() {
        boolean output = false; //be pessimistic. 
        Configurations configs = new Configurations();
        try {
            XMLConfiguration config = configs.xml("config/configuration.xml"); //this is a really nice factory implementation we're eliding
            //use XPATH so we can query attributes. NB that this means we'll be using slash-style lookup as in 
            // "processing/paths/excelFilePath" 
            // instead of 
            // "processing.paths.excelFilePath"
            config.setExpressionEngine(new XPathExpressionEngine());
            configurationEnvironment = config.getString("environment/env");
            verboseMode = Boolean.valueOf(config.getString("environment/verbose"));
            if (verboseMode) { System.out.println("User directory is " + System.getProperty("user.dir")); }
            if (verboseMode) { System.out.println(configurationEnvironment); } 
            excelFilePath = config.getString("processing[@env='" + configurationEnvironment + "']/paths/excelFilePath");
            excelSubdirectory = config.getString("processing[@env='" + configurationEnvironment + "']/paths/excelSubdirectory");
            bodymediaFileUrl = config.getString("processing[@env='" + configurationEnvironment + "']/paths/bodymediaFileUrl");
            //HierarchicalConfiguration node = (HierarchicalConfiguration) config.configurationAt("/nodes/node[@id='"+(str)+"']");
            List<String> emails = config.getList(String.class, "processing[@env='" + configurationEnvironment + "']/emails/email");
            privateMails = new String[emails.size()];
            privateMails = emails.toArray(privateMails);
            
            kj_start = config.getInt("processing[@env='" + configurationEnvironment + "']/defaults/kj_start"); 
            gs_initial = config.getDouble("processing[@env='" + configurationEnvironment + "']/defaults/gs_initial"); 
            ee_in = config.getDouble("processing[@env='" + configurationEnvironment + "']/defaults/ee_in"); 
           gsr_in = config.getDouble("processing[@env='" + configurationEnvironment + "']/defaults/gsr_in");  
           sleep_in = config.getDouble("processing[@env='" + configurationEnvironment + "']/defaults/sleep_in");  
           phys_act_in = config.getDouble("processing[@env='" + configurationEnvironment + "']/defaults/phys_act_in");  
           body_weight = config.getDouble("processing[@env='" + configurationEnvironment + "']/defaults/body_weight"); 
           
            output = true;
        } catch (ConfigurationException cex) {
            //Something went wrong; we should probably check to see if the configuration file wasn't found, 
            // but otherwise just keep the output as false.
            System.out.println(cex.getMessage());
        }
        return output;
    }

    //////////////////////////////Matrix Handling functions for the Program/////////////////////////////////////////////////////////////////////////////////////////
    /**
     * createNewMatrix - creates a new 2D matrix from an old matrix. 
     * Increases the size
     * 
     * Typically used to duplicate a matrix as : 
     * Matrix newMatrix = DIAS.createnewMatrix(oldMatrix.getRowDimension(), oldMatrix.getColumnDimension(), oldMatrix); 
     * @param newdimensionx
     * @param newdimensiony
     * @param oldmatrice
     * @return 
     */
    public static Matrix createnewMatrix(int newdimensionx, int newdimensiony, Matrix oldMatrix) {
        Matrix newMatrice = new Matrix(newdimensionx, newdimensiony);

        for (int i = 0; i < oldMatrix.getRowDimension(); i++) {
            for (int j = 0; j < oldMatrix.getColumnDimension(); j++) {
                newMatrice.set(i, j, oldMatrix.get(i, j));
            }
        }

        return newMatrice;
    }
    
    public static Matrix absMatrix(Matrix m1) { 
        Matrix r = new Matrix(m1.getRowDimension(), m1.getColumnDimension());
        for (int i = 0; i < m1.getRowDimension(); i++) {
            for (int j = 0; j < m1.getColumnDimension(); j++) {
                Double curValue = m1.get(i, j); 
                r.set(i, j, (curValue < 0 ? -curValue : curValue)); 
            }
        }
        return r; 
    } 
    
    //XXX OPTIMIZE : Make sure that the matrices are the same dimensions. 
    /**
     * maxMatrix : takes two matrices of the same size and returns a matrix filled with the value from m1 or m2, whichever is greater. 
     * 
     * @param m1
     * @param m2
     * @return 
     */
    public static Matrix maxMatrix(Matrix m1, Matrix m2) { 
        Matrix r = new Matrix(m1.getRowDimension(), m1.getColumnDimension()); 
        for (int i = 0; i < m1.getRowDimension(); i++) {
            for (int j = 0; j < m1.getColumnDimension(); j++) {
                r.set(i, j, Math.max(m1.get(i, j), m2.get(i, j))); 
            }
        }
        return r; 
    } 

    /**
     * printMatrix - print on terminal a 2D matrix an its name
     *
     * @param m
     * @param name
     */
    public static void printMatrix(Matrix m, String name) {
        System.out.print("\n " + name + ": \n{");
        for (double[] row : m.getArray()) {
            for (double val : row) {
                System.out.print(" " + val);
            }
            System.out.println();
        }
        System.out.println("}");
    }

    /**
     * print3DMatrix - - print on terminal a 3D matrix an its name
     *
     * @param x - 3D array (matrix)
     * @param matrixname
     */
    public static void print3DMatrix(double x[][][], String matrixname) {

        int[] valuex;
        valuex = lastValueReturnXYZ(x);

        System.out.println(matrixname);

        for (int k = 0; k < valuex[3] + 1; k++) {
            for (int i = 0; i < valuex[1] + 1; i++) {
                for (int j = 0; j < valuex[2] + 1; j++) {
                    System.out.print("\t\t\t" + x[i][j][k]);
                }
                System.out.println();
            }
            System.out.println("Matrice State:  " + (k + 1));
        }
        System.out.println("Matrice has written");

    }

    /**
     * lastValueReturnXYZ - returns the last non zero value in each of the
     * coordinates XYZ
     *
     * @param s - 3D array (matrix)
     * @return
     */
    public static int[] lastValueReturnXYZ(double s[][][]) {
        int lastvaluex = 0;
        int lastvaluey = 0;
        int lastvaluez = 0;

        for (int i = 0; i < s.length; i++) {
            for (int j = 0; j < s[0].length; j++) {
                for (int z = 0; z < s[0][0].length; z++) {
                    if (s[i][j][z] != 0) {
                        lastvaluex = i;
                        lastvaluey = j;
                        lastvaluez = z;
                    }
                }
            }
        }
        int[] dizi = new int[4];
        dizi[1] = lastvaluex;
        dizi[2] = lastvaluey;
        dizi[3] = lastvaluez;

        return dizi;
    }
    /**
     * matrixLastValueReturnX - return the position of the last non zero value
     * in the matrix
     * @param s
     * @return 
     */

    public static int[] matrixLastValueReturnXY(Matrix s) {
        int lastvaluex = 0;
        int lastvaluey = 0;

        for (int i = 0; i < s.getColumnDimension(); i++) {
            for (int j = 0; j < s.getRowDimension(); j++) {
                if (s.get(i, j) != 0) {
                    lastvaluex = i;
                    lastvaluey = j;
                }
            }
        }
        int[] resultlocation = new int[2];
        resultlocation[0] = lastvaluex;
        resultlocation[1] = lastvaluey;

        return resultlocation;
    }
    
    

}
